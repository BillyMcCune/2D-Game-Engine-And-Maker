package oogasalad.editor.view;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import java.util.ResourceBundle;
import java.util.UUID;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import javafx.application.Platform;
import javafx.geometry.Insets;
import javafx.scene.Node;
import javafx.scene.control.Alert;
import javafx.scene.control.ScrollPane;
import javafx.scene.layout.AnchorPane;
import javafx.scene.layout.Pane;
import javafx.scene.layout.VBox;
import oogasalad.editor.controller.EditorController;
import oogasalad.editor.model.data.event_enum.ConditionType;
import oogasalad.editor.model.data.event_enum.OutcomeType;
import oogasalad.editor.model.data.object.DynamicVariable;
import oogasalad.editor.model.data.object.DynamicVariableContainer;
import oogasalad.editor.model.data.object.event.EditorEvent;
import oogasalad.editor.model.data.object.event.ExecutorData;
import oogasalad.editor.view.resources.EditorResourceLoader;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;


/**
 * Factory responsible for creating the UI components within the "Input" or "Events" tab
 * of the editor. It integrates builders for managing events, conditions, and outcomes,
 * connecting them to the EditorController and handling data flow based on object/event selection.
 * Implements {@link EditorViewListener} to react to changes in the editor's state.
 */
public class InputTabComponentFactory implements EditorViewListener {

  private static final Logger LOG = LogManager.getLogger(InputTabComponentFactory.class);

  private static final String UI_BUNDLE_NAME = "InputTabUI";
  private static final String CSS_PATH = "/css/editor/editor.css";
  private static final String KEY_ERROR_SELECTION_NEEDED = "errorSelectionNeeded";
  private static final String KEY_ERROR_API_FAILURE = "errorApiFailureTitle";
  private static final String KEY_ERROR_ACTION_FAILED = "errorActionFailedContent";

  private static final double DEFAULT_PADDING = 12.0;
  private static final double SECTION_SPACING = 25.0;

  private final EditorController editorController;
  private final ResourceBundle uiBundle;

  private EventsSectionBuilder eventsSectionBuilder;
  private ConditionsSectionBuilder conditionsSectionBuilder;
  private OutcomesSectionBuilder outcomesSectionBuilder;

  private UUID currentObjectId;
  private String currentEventId;

  /**
   * Constructs an InputTabComponentFactory.
   *
   * @param editorController The controller responsible for handling editor logic. Must not be null.
   * @throws NullPointerException if editorController is null.
   * @throws RuntimeException     if the UI resource bundle cannot be loaded.
   */
  public InputTabComponentFactory(EditorController editorController) {
    this.editorController = Objects.requireNonNull(editorController, "EditorController cannot be null.");
    try {
      this.uiBundle = EditorResourceLoader.loadResourceBundle(UI_BUNDLE_NAME);
    } catch (Exception e) {
      LOG.fatal("Failed to load essential UI resource bundle {}. Cannot continue.", UI_BUNDLE_NAME, e);
      throw new RuntimeException("Failed to load UI resource bundle: " + UI_BUNDLE_NAME, e);
    }
    createSectionBuilders();
    LOG.info("InputTabComponentFactory initialized.");
  }

  /**
   * Initializes the section builder instances (Events, Conditions, Outcomes)
   * required for constructing the UI components. This involves passing the resource bundle,
   * necessary data suppliers, and handler method references to the builder constructors.
   */
  private void createSectionBuilders() {
    eventsSectionBuilder = new EventsSectionBuilder(
        uiBundle,
        this::handleAddEvent,
        this::handleRemoveEvent,
        this::handleEventSelectionChange
    );

    conditionsSectionBuilder = new ConditionsSectionBuilder(
        uiBundle,
        this::getConditionTypeNames,
        this::handleAddConditionGroup,
        this::handleRemoveConditionGroup,
        this::handleAddCondition,
        this::handleRemoveCondition,
        this::handleEditConditionParam
    );

    outcomesSectionBuilder = new OutcomesSectionBuilder(
        uiBundle,
        this::getOutcomeTypeNames,
        this::getDynamicVariablesForObject,
        this::handleAddOutcome,
        this::handleRemoveOutcome,
        this::openAddDynamicVariableDialog,
        this::handleEditOutcomeParam
    );
  }


  /**
   * Creates the main content pane for the Input tab. This pane includes sections for managing
   * events, conditions, and outcomes, generated by their respective builders, and arranged
   * vertically within a scrollable container.
   *
   * @return A Pane (typically an AnchorPane wrapping a ScrollPane) containing the UI for the Input tab.
   */
  public Pane createInputTabPanel() {
    VBox contentVBox = new VBox(SECTION_SPACING);
    contentVBox.setPadding(new Insets(DEFAULT_PADDING));
    contentVBox.setId("input-tab-content-vbox");

    Node eventsSection = eventsSectionBuilder.build();
    Node conditionsSection = conditionsSectionBuilder.build();
    Node outcomesSection = outcomesSectionBuilder.build();

    contentVBox.getChildren().addAll(eventsSection, conditionsSection, outcomesSection);

    ScrollPane scrollPane = new ScrollPane(contentVBox);
    scrollPane.setFitToWidth(true);
    scrollPane.setFitToHeight(false);
    scrollPane.setHbarPolicy(ScrollPane.ScrollBarPolicy.NEVER);
    scrollPane.setVbarPolicy(ScrollPane.ScrollBarPolicy.AS_NEEDED);
    scrollPane.setId("input-tab-scroll-pane");

    AnchorPane rootPane = new AnchorPane();
    rootPane.getChildren().add(scrollPane);
    AnchorPane.setTopAnchor(scrollPane, 0.0);
    AnchorPane.setBottomAnchor(scrollPane, 0.0);
    AnchorPane.setLeftAnchor(scrollPane, 0.0);
    AnchorPane.setRightAnchor(scrollPane, 0.0);

    clearAllUIToDefault();
    LOG.debug("Input tab panel created using AnchorPane -> ScrollPane -> VBox.");

    return rootPane;
  }


  /**
   * Handles the selection change event in the events list view (triggered by EventsSectionBuilder).
   * Updates the internal state (`currentEventId`) and refreshes the conditions and outcomes lists
   * based on the newly selected event. Ensures execution on the JavaFX Application Thread.
   *
   * @param selectedEventId The ID of the newly selected event, or null if deselected.
   */
  private void handleEventSelectionChange(String selectedEventId) {
    runOnFxThread(() -> {
      this.currentEventId = selectedEventId;
      LOG.debug("Internal state: Event selection changed to: {}", currentEventId);
      refreshConditionsAndOutcomesForEvent();
    });
  }

  /**
   * Handles the action to add a new event to the currently selected object.
   * Delegates the action to the {@link EditorController} via the correct data manager access.
   * Explicitly refreshes the events list upon successful addition. Shows an error if no object
   * is selected or if the controller reports an error.
   *
   * @param eventId The ID (String) of the event to add.
   */
  private void handleAddEvent(String eventId) {
    LOG.debug("Add Event action triggered for ID: {}", eventId);
    if (!isSelected(true, false)) return;
    try {
      editorController.getEditorDataAPI().getInputDataAPI().addEvent(currentObjectId, eventId);
      LOG.info("Delegated add event '{}' for object {}", eventId, currentObjectId);
      refreshEventsList(); // Explicitly refresh the list after adding
    } catch (Exception e) {
      LOG.error("Error delegating add event: {}", e.getMessage(), e);
      showErrorAlert(KEY_ERROR_API_FAILURE, String.format(uiBundle.getString(KEY_ERROR_ACTION_FAILED), "add event", e.getMessage()));
    }
  }

  /**
   * Handles the action to remove the selected event (obtained from EventsSectionBuilder's list view)
   * from the currently selected object. Delegates the action to the {@link EditorController}.
   * Explicitly refreshes the events list upon successful removal. Shows an error if no object or event is selected,
   * or if the controller reports an error.
   */
  private void handleRemoveEvent() {
    LOG.debug("Remove Event action triggered.");
    String selectedEvent = eventsSectionBuilder.getEventListView().getSelectionModel().getSelectedItem();
    if (!isSelected(true, false) || selectedEvent == null) {
      showErrorAlert(KEY_ERROR_SELECTION_NEEDED, "An object and an event must be selected for removal.");
      return;
    }
    try {
      editorController.getEditorDataAPI().getInputDataAPI().removeEvent(currentObjectId, selectedEvent);
      LOG.info("Delegated remove event '{}' for object {}", selectedEvent, currentObjectId);
      refreshEventsList(); // Explicitly refresh the list after removing
    } catch (Exception e) {
      LOG.error("Error delegating remove event: {}", e.getMessage(), e);
      showErrorAlert(KEY_ERROR_API_FAILURE, String.format(uiBundle.getString(KEY_ERROR_ACTION_FAILED), "remove event", e.getMessage()));
    }
  }

  /**
   * Handles the action to add an empty condition group to the currently selected event.
   * Delegates to the controller and refreshes the conditions list upon success.
   */
  private void handleAddConditionGroup() {
    LOG.debug("Add Condition Group action triggered.");
    if (!isSelected(true, true)) return;
    try {
      editorController.getEditorDataAPI().getInputDataAPI().addConditionGroup(currentObjectId, currentEventId);
      refreshConditionsAndOutcomesForEvent();
    } catch (Exception e) {
      LOG.error("Error delegating add condition group: {}", e.getMessage(), e);
      showErrorAlert(KEY_ERROR_API_FAILURE, String.format(uiBundle.getString(KEY_ERROR_ACTION_FAILED), "add condition group", e.getMessage()));
    }
  }

  /**
   * Handles the action to remove a condition group at the specified index from the current event.
   * Delegates to the controller and refreshes the conditions list upon success.
   *
   * @param groupIndex The index of the condition group to remove.
   */
  private void handleRemoveConditionGroup(int groupIndex) {
    LOG.debug("Remove Condition Group action triggered for group index: {}", groupIndex);
    if (!isSelected(true, true)) return;
    try {
      editorController.getEditorDataAPI().getInputDataAPI().removeConditionGroup(currentObjectId, currentEventId, groupIndex);
      refreshConditionsAndOutcomesForEvent();
    } catch (Exception e) {
      LOG.error("Error delegating remove condition group: {}", e.getMessage(), e);
      showErrorAlert(KEY_ERROR_API_FAILURE, String.format(uiBundle.getString(KEY_ERROR_ACTION_FAILED), "remove condition group", e.getMessage()));
    }
  }

  /**
   * Handles the action to add a condition of the specified type to a specific group within the current event.
   * Delegates to the controller and refreshes the conditions list upon success.
   *
   * @param groupIndex The index of the condition group to add to.
   * @param conditionType The string identifier of the condition type to add.
   */
  private void handleAddCondition(int groupIndex, String conditionType) {
    LOG.debug("Add Condition action triggered for type: {} in group {}", conditionType, groupIndex);
    if (!isSelected(true, true)) return;
    try {
      editorController.getEditorDataAPI().getInputDataAPI().addEventCondition(currentObjectId, currentEventId, groupIndex, conditionType);
      refreshConditionsAndOutcomesForEvent();
    } catch (Exception e) {
      LOG.error("Error delegating add condition: {}", e.getMessage(), e);
      showErrorAlert(KEY_ERROR_API_FAILURE, String.format(uiBundle.getString(KEY_ERROR_ACTION_FAILED), "add condition", e.getMessage()));
    }
  }

  /**
   * Handles the action to remove a condition at the specified group and index within the current event.
   * Delegates to the controller and refreshes the conditions list upon success.
   *
   * @param groupIndex The index of the condition group.
   * @param conditionIndex The index of the condition within the group to remove.
   */
  private void handleRemoveCondition(int groupIndex, int conditionIndex) {
    LOG.debug("Remove Condition action triggered for group {}, index {}", groupIndex, conditionIndex);
    if (!isSelected(true, true)) return;
    try {
      editorController.getEditorDataAPI().getInputDataAPI().removeEventCondition(currentObjectId, currentEventId, groupIndex, conditionIndex);
      refreshConditionsAndOutcomesForEvent();
    } catch (Exception e) {
      LOG.error("Error delegating remove condition: {}", e.getMessage(), e);
      showErrorAlert(KEY_ERROR_API_FAILURE, String.format(uiBundle.getString(KEY_ERROR_ACTION_FAILED), "remove condition", e.getMessage()));
    }
  }

  /**
   * Handles the modification of a specific parameter for a condition.
   * Delegates the update to the controller. Catches exceptions and may refresh the UI on failure.
   *
   * @param groupIndex The index of the condition's group.
   * @param conditionIndex The index of the condition within its group.
   * @param paramName The name of the parameter being edited.
   * @param value The new value for the parameter (expected to be String or Double).
   */
  private void handleEditConditionParam(int groupIndex, int conditionIndex, String paramName, Object value) {
    LOG.trace("Edit Condition Param: group={}, index={}, param={}, value={}", groupIndex, conditionIndex, paramName, value);
    if (!isSelected(true, true)) return;
    try {
      if (value instanceof String strValue) {
        editorController.getEditorDataAPI().getInputDataAPI().setEventConditionStringParameter(
            currentObjectId, currentEventId, groupIndex, conditionIndex, paramName, strValue);
      } else if (value instanceof Double doubleValue) {
        editorController.getEditorDataAPI().getInputDataAPI().setEventConditionDoubleParameter(
            currentObjectId, currentEventId, groupIndex, conditionIndex, paramName, doubleValue);
      } else {
        LOG.warn("Unsupported parameter type for condition: {}", value == null ? "null" : value.getClass().getName());
        return;
      }
    } catch (Exception e) {
      LOG.error("Error delegating edit condition parameter: {}", e.getMessage(), e);
      showErrorAlert(KEY_ERROR_API_FAILURE, String.format(uiBundle.getString(KEY_ERROR_ACTION_FAILED), "edit condition parameter", e.getMessage()));
      refreshConditionsAndOutcomesForEvent();
    }
  }


  /**
   * Handles the action to add an outcome of the specified type to the current event.
   * Delegates to the controller and refreshes the outcomes list upon success.
   *
   * @param outcomeType The string identifier of the outcome type to add.
   */
  private void handleAddOutcome(String outcomeType) {
    LOG.debug("Add Outcome action triggered for type: {}", outcomeType);
    if (!isSelected(true, true)) return;
    try {
      editorController.getEditorDataAPI().getInputDataAPI().addEventOutcome(currentObjectId, currentEventId, outcomeType);
      refreshConditionsAndOutcomesForEvent();
    } catch (Exception e) {
      LOG.error("Error delegating add outcome: {}", e.getMessage(), e);
      showErrorAlert(KEY_ERROR_API_FAILURE, String.format(uiBundle.getString(KEY_ERROR_ACTION_FAILED), "add outcome", e.getMessage()));
    }
  }

  /**
   * Handles the action to remove an outcome at the specified index from the current event.
   * Delegates to the controller and refreshes the outcomes list upon success.
   *
   * @param outcomeIndex The index of the outcome to remove.
   */
  private void handleRemoveOutcome(int outcomeIndex) {
    LOG.debug("Remove Outcome action triggered for index {}", outcomeIndex);
    if (!isSelected(true, true)) return;
    try {
      editorController.getEditorDataAPI().getInputDataAPI().removeEventOutcome(currentObjectId, currentEventId, outcomeIndex);
      refreshConditionsAndOutcomesForEvent();
    } catch (Exception e) {
      LOG.error("Error delegating remove outcome: {}", e.getMessage(), e);
      showErrorAlert(KEY_ERROR_API_FAILURE, String.format(uiBundle.getString(KEY_ERROR_ACTION_FAILED), "remove outcome", e.getMessage()));
    }
  }

  /**
   * Handles the modification of a specific parameter for an outcome.
   * Delegates the update to the controller. Catches exceptions and may refresh the UI on failure.
   *
   * @param outcomeIndex The index of the outcome whose parameter is being edited.
   * @param paramName The name of the parameter being edited.
   * @param value The new value for the parameter (expected to be String or Double).
   */
  private void handleEditOutcomeParam(int outcomeIndex, String paramName, Object value) {
    LOG.trace("Edit Outcome Param: index={}, param={}, value={}", outcomeIndex, paramName, value);
    if (!isSelected(true, true)) return;
    try {
      if (value instanceof String strValue) {
        editorController.getEditorDataAPI().getInputDataAPI().setEventOutcomeStringParameter(
            currentObjectId, currentEventId, outcomeIndex, paramName, strValue);
      } else if (value instanceof Double doubleValue) {
        editorController.getEditorDataAPI().getInputDataAPI().setEventOutcomeDoubleParameter(
            currentObjectId, currentEventId, outcomeIndex, paramName, doubleValue);
      } else {
        LOG.warn("Unsupported parameter type for outcome: {}", value == null ? "null" : value.getClass().getName());
        return;
      }
    } catch (Exception e) {
      LOG.error("Error delegating edit outcome parameter: {}", e.getMessage(), e);
      showErrorAlert(KEY_ERROR_API_FAILURE, String.format(uiBundle.getString(KEY_ERROR_ACTION_FAILED), "edit outcome parameter", e.getMessage()));
      refreshConditionsAndOutcomesForEvent();
    }
  }


  /**
   * Opens a dialog window ({@link DynamicVariableDialog}) to allow the user to define and add
   * a new dynamic variable to the currently selected object. Requires an object to be selected.
   */
  private void openAddDynamicVariableDialog() {
    LOG.debug("Opening 'Add Dynamic Variable' dialog.");
    if (!isSelected(true, false)) return;
    DynamicVariableDialog dialog = new DynamicVariableDialog(uiBundle);
    Optional<DynamicVariable> result = dialog.showAndWait();
    result.ifPresent(this::handleAddDynamicVariable);
  }

  /**
   * Handles the result from the dynamic variable creation dialog. Delegates the addition
   * of the new dynamic variable to the {@link EditorController} via the {@link DynamicVariableContainer}.
   * Relies on {@link #onDynamicVariablesChanged()} listener to update the UI.
   *
   * @param dynamicVar The {@link DynamicVariable} object created by the user.
   */
  private void handleAddDynamicVariable(DynamicVariable dynamicVar) {
    try {
      if (dynamicVar == null) {
        LOG.warn("Attempted to add a null dynamic variable.");
        return;
      }
      DynamicVariableContainer container = editorController.getEditorDataAPI().getDynamicVariableContainer();
      if (container != null) {
        container.addVariable(dynamicVar);
        LOG.info("Delegated add dynamic variable: {}", dynamicVar.getName());
      } else {
        LOG.error("DynamicVariableContainer is null, cannot add variable.");
        showErrorAlert(KEY_ERROR_API_FAILURE, "Internal error: Cannot access variable storage.");
      }

    } catch (Exception e) {
      LOG.error("Error delegating add dynamic variable: {}", e.getMessage(), e);
      showErrorAlert(KEY_ERROR_API_FAILURE, String.format(uiBundle.getString(KEY_ERROR_ACTION_FAILED), "add dynamic variable", e.getMessage()));
    }
  }


  /**
   * Provides the list of available condition type names (Strings) to the ConditionsSectionBuilder.
   * This implementation currently derives the names directly from the {@link ConditionType} enum.
   * @return A sorted List of condition type names.
   */
  private List<String> getConditionTypeNames() {
    return Stream.of(ConditionType.values()).map(Enum::name).sorted().collect(Collectors.toList());
  }

  /**
   * Provides the list of available outcome type names (Strings) to the OutcomesSectionBuilder.
   * This implementation currently derives the names directly from the {@link OutcomeType} enum.
   * @return A sorted List of outcome type names.
   */
  private List<String> getOutcomeTypeNames() {
    return Stream.of(OutcomeType.values()).map(Enum::name).sorted().collect(Collectors.toList());
  }

  /**
   * Provides the list of {@link DynamicVariable}s associated with the currently selected object
   * to the OutcomesSectionBuilder for its variable selection ComboBox.
   * Retrieves variables from the {@link DynamicVariableContainer}.
   * Returns an empty list if no object is selected or an error occurs during fetching.
   * @return List of {@link DynamicVariable} objects for the current object.
   */
  private List<DynamicVariable> getDynamicVariablesForObject() {
    if (currentObjectId == null) {
      return Collections.emptyList();
    }
    try {
      DynamicVariableContainer container = editorController.getEditorDataAPI().getDynamicVariableContainer();
      if (container != null) {
        Collection<DynamicVariable> vars = container.getAllVariables();
        return (vars != null) ? new ArrayList<>(vars) : Collections.emptyList();
      } else {
        LOG.warn("DynamicVariableContainer is null, cannot retrieve variables.");
        return Collections.emptyList();
      }
    } catch (Exception e) {
      LOG.error("Failed to get dynamic variables for object {}: {}", currentObjectId, e.getMessage(), e);
      return Collections.emptyList();
    }
  }


  /**
   * Safely executes a {@link Runnable} action on the JavaFX Application Thread.
   * If called from the FX thread, it runs immediately. Otherwise, it uses {@link Platform#runLater(Runnable)}.
   *
   * @param action The action to execute on the FX thread.
   */
  private void runOnFxThread(Runnable action) {
    if (Platform.isFxApplicationThread()) {
      action.run();
    } else {
      Platform.runLater(action);
    }
  }

  /**
   * Refreshes the entire UI associated with this factory (events, conditions, outcomes, dynamic variables)
   * based on the currently selected object ID. Ensures execution on the JavaFX Application Thread.
   */
  private void refreshUIForObject() {
    runOnFxThread(() -> {
      LOG.debug("Refreshing UI for object: {}", currentObjectId);
      refreshEventsList();
      refreshDynamicVariables();
    });
  }

  /**
   * Refreshes the events list in the UI based on the {@code currentObjectId}.
   * Fetches the events, updates the list view in {@link EventsSectionBuilder}, and attempts
   * to re-select the previously selected event. If no event is selected or re-selection fails,
   * it clears the conditions and outcomes UI sections. Ensures execution on the JavaFX Application Thread.
   */
  private void refreshEventsList() {
    runOnFxThread(() -> {
      String previouslySelectedEvent = currentEventId;
      Map<String, EditorEvent> events = fetchEventsForCurrentObject();

      if (events == null) {
        eventsSectionBuilder.getEventListView().getItems().clear();
        clearConditionsAndOutcomesUI();
        return;
      }

      List<String> sortedEventIds = events.keySet().stream().sorted().collect(Collectors.toList());
      eventsSectionBuilder.getEventListView().getItems().setAll(sortedEventIds);

      if (previouslySelectedEvent != null && sortedEventIds.contains(previouslySelectedEvent)) {
        eventsSectionBuilder.getEventListView().getSelectionModel().select(previouslySelectedEvent);
      } else {
        clearConditionsAndOutcomesUI();
      }
      LOG.debug("Refreshed events list for object {}: {} events.", currentObjectId, sortedEventIds.size());
    });
  }


  /**
   * Fetches the map of event IDs to {@link EditorEvent} objects for the {@code currentObjectId}
   * from the controller using the correct data manager access method.
   * Handles exceptions during the fetch operation.
   * @return A Map of event IDs to EditorEvent objects, or null if an error occurs or no object is selected.
   */
  private Map<String, EditorEvent> fetchEventsForCurrentObject() {
    if (currentObjectId == null) {
      return Collections.emptyMap();
    }
    try {
      return editorController.getEditorDataAPI().getInputDataAPI().getEvents(currentObjectId);
    } catch (Exception e) {
      LOG.error("Controller failed to get events for object {}: {}", currentObjectId, e.getMessage(), e);
      showErrorAlert(KEY_ERROR_API_FAILURE, String.format(uiBundle.getString(KEY_ERROR_ACTION_FAILED), "fetch events", e.getMessage()));
      return null;
    }
  }

  /**
   * Refreshes the conditions and outcomes UI sections based on the {@code currentEventId}.
   * Fetches the relevant data from the controller and updates the corresponding builders.
   * Ensures execution on the JavaFX Application Thread.
   */
  private void refreshConditionsAndOutcomesForEvent() {
    runOnFxThread(() -> {
      LOG.debug("Refreshing conditions and outcomes for event: {}", currentEventId);
      List<List<ExecutorData>> conditions = fetchConditionsForCurrentEvent();
      List<ExecutorData> outcomes = fetchOutcomesForCurrentEvent();

      conditionsSectionBuilder.updateConditionsListView(conditions);
      outcomesSectionBuilder.updateOutcomesListView(outcomes);
    });
  }

  /**
   * Fetches the list of condition groups (each group being a list of {@link ExecutorData})
   * for the current object and event from the controller using the correct data manager access method.
   * Handles exceptions.
   * @return A List of condition groups (List<List<ExecutorData>>), or null if an error occurs or no event/object is selected.
   */
  private List<List<ExecutorData>> fetchConditionsForCurrentEvent() {
    if (currentObjectId == null || currentEventId == null) {
      return null;
    }
    try {
      return editorController.getEditorDataAPI().getInputDataAPI().getEventConditions(currentObjectId, currentEventId);
    } catch (Exception e) {
      LOG.error("Controller failed to get conditions for event {}: {}", currentEventId, e.getMessage(), e);
      showErrorAlert(KEY_ERROR_API_FAILURE, String.format(uiBundle.getString(KEY_ERROR_ACTION_FAILED), "fetch conditions", e.getMessage()));
      return null;
    }
  }

  /**
   * Fetches the list of outcomes (as {@link ExecutorData}) for the current object and event from the controller
   * using the correct data manager access method. Handles exceptions.
   * @return A List of outcomes (List<ExecutorData>), or null if an error occurs or no event/object is selected.
   */
  private List<ExecutorData> fetchOutcomesForCurrentEvent() {
    if (currentObjectId == null || currentEventId == null) {
      return null;
    }
    try {
      return editorController.getEditorDataAPI().getInputDataAPI().getEventOutcomes(currentObjectId, currentEventId);
    } catch (Exception e) {
      LOG.error("Controller failed to get outcomes for event {}: {}", currentEventId, e.getMessage(), e);
      showErrorAlert(KEY_ERROR_API_FAILURE, String.format(uiBundle.getString(KEY_ERROR_ACTION_FAILED), "fetch outcomes", e.getMessage()));
      return null;
    }
  }

  /**
   * Refreshes the dynamic variable combo box in the {@link OutcomesSectionBuilder} by triggering
   * its update method. Ensures execution on the JavaFX Application Thread.
   */
  private void refreshDynamicVariables() {
    runOnFxThread(() -> {
      LOG.debug("Refreshing dynamic variables for object: {}", currentObjectId);
      outcomesSectionBuilder.updateDynamicVariableComboBox();
    });
  }

  /**
   * Clears the UI components related to conditions and outcomes within their respective builders.
   * Also resets the {@code currentEventId} to null. Ensures execution on the JavaFX Application Thread.
   */
  private void clearConditionsAndOutcomesUI() {
    runOnFxThread(() -> {
      this.currentEventId = null;
      conditionsSectionBuilder.updateConditionsListView(null);
      outcomesSectionBuilder.updateOutcomesListView(null);
      LOG.trace("Cleared conditions and outcomes UI sections.");
    });
  }

  /**
   * Clears all UI elements managed by this factory to their default empty state.
   * Clears the event list and field, conditions list, outcomes list, and dynamic variables combo box.
   * Ensures execution on the JavaFX Application Thread.
   */
  private void clearAllUIToDefault() {
    runOnFxThread(() -> {
      eventsSectionBuilder.getEventListView().getItems().clear();
      eventsSectionBuilder.getEventIdField().clear();
      conditionsSectionBuilder.updateConditionsListView(null);
      outcomesSectionBuilder.updateOutcomesListView(null);
      refreshDynamicVariables();
      LOG.trace("Cleared all input tab UI to default.");
    });
  }

  /**
   * Checks if the required selections (object and/or event) are currently available.
   * If a required selection is missing, logs a warning and displays an error alert to the user.
   * Must be called on the JavaFX Application thread if potentially showing an alert.
   *
   * @param requireObjectSelection If true, checks if {@code currentObjectId} is non-null.
   * @param requireEventSelection If true, checks if {@code currentEventId} is non-null.
   * @return {@code true} if all required selections are present, {@code false} otherwise.
   */
  private boolean isSelected(boolean requireObjectSelection, boolean requireEventSelection) {
    if (requireObjectSelection && currentObjectId == null) {
      LOG.warn("Action requires an object selection, but none found.");
      showErrorAlert(KEY_ERROR_SELECTION_NEEDED, "An object must be selected.");
      return false;
    }
    if (requireEventSelection && currentEventId == null) {
      LOG.warn("Action requires an event selection, but none found.");
      showErrorAlert(KEY_ERROR_SELECTION_NEEDED, "An event must be selected.");
      return false;
    }
    return true;
  }


  /**
   * Displays an error alert dialog to the user on the JavaFX Application Thread.
   * Uses text from the resource bundle for the title and formats the content message.
   * Attempts to apply custom CSS styling to the dialog.
   *
   * @param titleKey    The resource bundle key for the alert title.
   * @param contentText The main message text to display in the alert.
   */
  private void showErrorAlert(String titleKey, String contentText) {
    runOnFxThread(() -> {
      Alert alert = new Alert(Alert.AlertType.ERROR);
      alert.setTitle(uiBundle.containsKey(titleKey) ? uiBundle.getString(titleKey) : titleKey);
      alert.setHeaderText(null);
      alert.setContentText(contentText);
      try {
        String cssUrl = Objects.requireNonNull(getClass().getResource(CSS_PATH)).toExternalForm();
        alert.getDialogPane().getStylesheets().add(cssUrl);
      } catch (Exception e) {
        LOG.warn("Could not apply CSS {} to error alert: {}", CSS_PATH, e.getMessage());
      }
      alert.showAndWait();
    });
  }


  /**
   * Called when an object is added to the editor model.
   * Triggers a refresh of the dynamic variables display.
   * Ensures execution on the JavaFX Application Thread.
   * @param objectId The UUID of the added object.
   */
  @Override
  public void onObjectAdded(UUID objectId) {
    LOG.trace("InputTab received: onObjectAdded {}", objectId);
    refreshDynamicVariables();
  }

  /**
   * Called when an object is removed from the editor model.
   * If the removed object was the one currently selected, clears the entire UI.
   * Always refreshes the dynamic variables display.
   * Ensures execution on the JavaFX Application Thread.
   * @param objectId The UUID of the removed object.
   */
  @Override
  public void onObjectRemoved(UUID objectId) {
    runOnFxThread(() -> {
      LOG.trace("InputTab received: onObjectRemoved {}", objectId);
      if (Objects.equals(this.currentObjectId, objectId)) {
        LOG.debug("Selected object {} was removed. Clearing input tab.", objectId);
        this.currentObjectId = null;
        this.currentEventId = null;
        clearAllUIToDefault();
      }
      refreshDynamicVariables();
    });
  }

  /**
   * Called when an object's data is updated in the editor model.
   * If the updated object is the one currently selected, refreshes the events list
   * (which may trigger subsequent refreshes of conditions/outcomes).
   * Always refreshes the dynamic variables display.
   * Ensures execution on the JavaFX Application Thread.
   * @param objectId The UUID of the updated object.
   */
  @Override
  public void onObjectUpdated(UUID objectId) {
    runOnFxThread(() -> {
      LOG.trace("InputTab received: onObjectUpdated {}", objectId);
      if (Objects.equals(this.currentObjectId, objectId)) {
        LOG.debug("Refreshing InputTab because selected object {} was updated.", objectId);
        refreshEventsList();
      }
      refreshDynamicVariables();
    });
  }

  /**
   * Called when the editor's object selection changes.
   * Updates the internal current object ID. If the selection changed,
   * either refreshes the UI for the new object or clears the UI if deselected.
   * Ensures execution on the JavaFX Application Thread.
   * @param selectedObjectId The UUID of the newly selected object, or null if deselected.
   */
  @Override
  public void onSelectionChanged(UUID selectedObjectId) {
    runOnFxThread(() -> {
      LOG.debug("InputTab received: onSelectionChanged {}", selectedObjectId);
      if (!Objects.equals(this.currentObjectId, selectedObjectId)) {
        this.currentObjectId = selectedObjectId;
        this.currentEventId = null;
        if (this.currentObjectId != null) {
          refreshUIForObject();
        } else {
          clearAllUIToDefault();
        }
      }
    });
  }

  /**
   * Called when the list of dynamic variables potentially changes in the model.
   * Triggers a refresh of the dynamic variables combo box in the UI.
   * Ensures execution on the JavaFX Application Thread.
   */
  @Override
  public void onDynamicVariablesChanged() {
    runOnFxThread(() -> {
      LOG.debug("InputTab received: onDynamicVariablesChanged");
      refreshDynamicVariables();
    });
  }

  /**
   * Called when a general error occurs elsewhere that should be reported to the user.
   * Displays the error message in an alert dialog.
   * @param errorMessage The error message to display.
   */
  @Override
  public void onErrorOccurred(String errorMessage) {
    LOG.warn("InputTab received: onErrorOccurred: {}", errorMessage);
    showErrorAlert(KEY_ERROR_API_FAILURE, errorMessage);
  }
}